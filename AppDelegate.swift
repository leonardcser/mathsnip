import Cocoa
import ScreenCaptureKit
import ApplicationServices

// MARK: - LaTeX Conversion Backend

enum LaTeXBackend: String {
    case texoCoreml = "texo-coreml"
    case texo
    case pix2tex
}

// Backend configuration is set in BackendConfig.swift (auto-generated by Makefile)

class AppDelegate: NSObject, NSApplicationDelegate {
    // MARK: - Properties

    var statusItem: NSStatusItem!
    var statusBarMenu: StatusBarMenu!
    var overlayPanel: OverlayPanel?
    var previewPanel: PreviewPanel?
    var isProcessing = false
    var normalIcon: NSImage?

    // Backend instances
    var pix2texBackend: Pix2TexBackend?
    var texoBackend: TexoBackend?
    var coremlBackend: TexoCoreMLBackend?

    // MARK: - Application Lifecycle

    func applicationDidFinishLaunching(_ notification: Notification) {
        setupStatusItem()
        setupMenu()
        initializeBackend()
    }

    func applicationWillTerminate(_ notification: Notification) {
        texoBackend?.stopDaemon()
    }

    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
        return false
    }

    // MARK: - Setup

    private func setupStatusItem() {
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.squareLength)
        statusItem.button?.target = self
        statusItem.button?.action = #selector(statusItemClicked(_:))
        statusItem.button?.sendAction(on: [.leftMouseUp, .rightMouseUp])

        let iconPath = Bundle.main.path(forResource: "icon", ofType: "png")!
        let icon = NSImage(contentsOfFile: iconPath)!
        icon.size = NSSize(width: 18, height: 18)
        normalIcon = icon
        setIconNormal()
    }

    private func setupMenu() {
        statusBarMenu = StatusBarMenu()
        statusBarMenu.onSnip = { [weak self] in
            guard let self, !self.isProcessing else { return }
            self.startSnipping()
        }
        statusBarMenu.onGitHub = {
            if let url = URL(string: "https://github.com/leonardcser/mathsnip") {
                NSWorkspace.shared.open(url)
            }
        }
        statusBarMenu.onQuit = {
            NSApplication.shared.terminate(nil)
        }
    }

    private func initializeBackend() {
        switch activeBackend {
        case .pix2tex:
            pix2texBackend = Pix2TexBackend()
        case .texo:
            let dir = backendDir(.texo)
            texoBackend = TexoBackend(backendDir: dir)
            texoBackend?.startDaemon()
        case .texoCoreml:
            coremlBackend = TexoCoreMLBackend()
            Task {
                let success = await coremlBackend?.loadModels() ?? false
                if !success {
                    await MainActor.run {
                        coremlBackend?.showSetupAlert()
                    }
                }
            }
        }
    }

    // MARK: - Icon State

    func setIconNormal() {
        if let icon = normalIcon {
            icon.isTemplate = true
            statusItem.button?.image = icon
            statusItem.button?.appearsDisabled = false
        }
    }

    func setIconLoading() {
        if let icon = normalIcon {
            icon.isTemplate = false
            statusItem.button?.image = icon
            statusItem.button?.appearsDisabled = true
        }
    }

    // MARK: - Status Item Click

    @objc func statusItemClicked(_ sender: Any?) {
        guard let event = NSApp.currentEvent else { return }

        if event.type == .rightMouseUp {
            statusBarMenu.show(from: statusItem)
        } else {
            if isProcessing { return }
            startSnipping()
        }
    }

    // MARK: - Permission Checks

    func checkAccessibilityPermission() -> Bool {
        return AXIsProcessTrusted()
    }

    func checkScreenCapturePermission() -> Bool {
        return CGPreflightScreenCaptureAccess()
    }

    func showPermissionAlert(title: String, message: String, settingsAction: @escaping () -> Void) {
        let alert = NSAlert()
        alert.messageText = title
        alert.informativeText = message
        alert.alertStyle = .warning
        alert.addButton(withTitle: "Open System Settings")
        alert.addButton(withTitle: "Cancel")

        if alert.runModal() == .alertFirstButtonReturn {
            settingsAction()
        }
    }

    func openAccessibilitySettings() {
        if let url = URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility") {
            NSWorkspace.shared.open(url)
        }
    }

    func openScreenCaptureSettings() {
        if let url = URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture") {
            NSWorkspace.shared.open(url)
        }
    }

    // MARK: - Backend Directory

    func backendDir(_ backend: LaTeXBackend) -> String {
        let cwdPath = "\(FileManager.default.currentDirectoryPath)/backends/\(backend.rawValue)"
        let homePath = "\(NSHomeDirectory())/.mathsnip/backends/\(backend.rawValue)"

        if FileManager.default.fileExists(atPath: cwdPath) {
            return cwdPath
        }
        return homePath
    }

    // MARK: - Snipping Flow

    func startSnipping() {
        // Check backend is available
        switch activeBackend {
        case .pix2tex:
            if pix2texBackend?.checkSetup() != true {
                pix2texBackend?.showSetupAlert()
                return
            }
        case .texo:
            if texoBackend?.checkSetup() != true {
                texoBackend?.showSetupAlert()
                return
            }
        case .texoCoreml:
            if coremlBackend?.isReady != true {
                coremlBackend?.showSetupAlert()
                return
            }
        }

        // Check accessibility permission (required for event tap)
        if !checkAccessibilityPermission() {
            showPermissionAlert(
                title: "Accessibility Permission Required",
                message: "MathSnip needs Accessibility access to capture mouse and keyboard events for the snipping overlay. Please grant permission in System Settings.",
                settingsAction: openAccessibilitySettings
            )
            return
        }

        // Check screen capture permission
        if !checkScreenCapturePermission() {
            showPermissionAlert(
                title: "Screen Recording Permission Required",
                message: "MathSnip needs Screen Recording access to capture the selected area. Please grant permission in System Settings.",
                settingsAction: openScreenCaptureSettings
            )
            return
        }

        overlayPanel?.close()
        overlayPanel = OverlayPanel(appDelegate: self)
        overlayPanel?.configureForOverlay()
        overlayPanel?.makeKeyAndOrderFront(nil)
    }

    func handleSelection(_ rect: NSRect) {
        overlayPanel?.cleanup()
        overlayPanel?.orderOut(nil)

        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.captureAndProcess(rect)
        }
    }

    func cancelSnipping() {
        overlayPanel?.cleanup()
        overlayPanel?.close()
        overlayPanel = nil
    }

    // MARK: - Capture and Process

    func captureAndProcess(_ rect: NSRect) {
        isProcessing = true
        setIconLoading()

        Task {
            var capturedLatex: String?

            do {
                if activeBackend == .texoCoreml {
                    if let cgImage = try await captureScreenRegionAsImage(rect) {
                        capturedLatex = await coremlBackend?.runInference(image: cgImage)
                    }
                } else {
                    if let path = try await captureScreenRegion(rect) {
                        switch activeBackend {
                        case .pix2tex:
                            capturedLatex = pix2texBackend?.runInference(imagePath: path)
                        case .texo:
                            capturedLatex = texoBackend?.runInference(imagePath: path)
                        case .texoCoreml:
                            break
                        }
                        try? FileManager.default.removeItem(atPath: path)
                    }
                }

                if let latex = capturedLatex, !latex.isEmpty {
                    await MainActor.run {
                        let pasteboard = NSPasteboard.general
                        pasteboard.clearContents()
                        pasteboard.setString(latex, forType: .string)
                    }
                }
            } catch {
                print("Error: \(error)")
            }

            let finalLatex = capturedLatex

            await MainActor.run {
                self.isProcessing = false
                self.setIconNormal()
                self.overlayPanel?.close()
                self.overlayPanel = nil

                if let latex = finalLatex {
                    self.showPreview(latex: latex)
                }
            }
        }
    }

    // MARK: - Screen Capture

    func captureScreenRegionAsImage(_ rect: NSRect) async throws -> CGImage? {
        let content = try await SCShareableContent.excludingDesktopWindows(false, onScreenWindowsOnly: true)

        guard let display = content.displays.first else {
            return nil
        }

        let filter = SCContentFilter(display: display, excludingWindows: [])
        let scale = NSScreen.main?.backingScaleFactor ?? 1.0

        let config = SCStreamConfiguration()
        config.width = Int(CGFloat(display.width) * scale)
        config.height = Int(CGFloat(display.height) * scale)
        config.pixelFormat = kCVPixelFormatType_32BGRA
        config.showsCursor = false

        let image = try await SCScreenshotManager.captureImage(
            contentFilter: filter,
            configuration: config
        )

        let screenHeight = NSScreen.main?.frame.height ?? CGFloat(display.height)

        let cropRect = CGRect(
            x: rect.origin.x * scale,
            y: (screenHeight - rect.origin.y - rect.height) * scale,
            width: rect.width * scale,
            height: rect.height * scale
        )

        return image.cropping(to: cropRect)
    }

    func captureScreenRegion(_ rect: NSRect) async throws -> String? {
        guard let croppedImage = try await captureScreenRegionAsImage(rect) else {
            return nil
        }

        let tempDir = FileManager.default.temporaryDirectory
        let fileName = "mathsnip_\(Int(Date().timeIntervalSince1970)).png"
        let filePath = tempDir.appendingPathComponent(fileName)

        let bitmapRep = NSBitmapImageRep(cgImage: croppedImage)
        guard let pngData = bitmapRep.representation(using: .png, properties: [:]) else {
            return nil
        }

        try pngData.write(to: filePath)
        return filePath.path
    }

    // MARK: - Preview

    func showPreview(latex: String) {
        previewPanel?.dismiss()
        previewPanel = PreviewPanel()
        previewPanel?.showBelow(statusItem: statusItem, latex: latex)
    }
}
